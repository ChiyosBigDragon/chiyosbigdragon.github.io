<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Spielsand</title>
    <link>https://chiyosbigdragon.github.io/blog/</link>
    <description>Recent content in Blog on Spielsand</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Tue, 27 Aug 2019 12:00:00 +0900</lastBuildDate>
    
	<atom:link href="https://chiyosbigdragon.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SRM730 Div1Easy StonesOnATree</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/27/</link>
      <pubDate>Tue, 27 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/27/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14811
概略 有向木の頂点に石を置いていくゲームを行う．葉には無条件で置いてよい．親に置くためには，その直接の子すべてに石が置かれていなければならない．また，任意のタイミングで石を取り除くことができる．根に石を置いた時点でゲームは終了する．
各頂点には重み $w$ が付いている．石が置かれている頂点 $i$ について $W = \sum w_i$ が逐一計算され，ゲームのスコアは $\max W$ である．スコアの最小値を求める．
方針 操作を先読みしたいときにはメモ化再帰が有効です．
dp[i] := iに石を置く操作をするときのスコアの最小値とします．頂点iの子がL，Rであるとき，iに石を置く操作には以下の工程が考えられます．
 Lに石を置く  dp[L]  Rに石を置く  dp[R]  Lに石を置く操作を一通り行った後，Rに置く操作を行う．またはその逆．これは小さい方を選択できる．  min(w[L] + dp[R], w[R] + dp[L])  LとRの両方に石が置かれていて，iに石を置く  w[i] + w[L] + w[R]   dp[i]はこのうちの最大値を取ります．子が0, 1つの場合も同様に計算できます．
[展開する]   反省 操作順を親と子の重みだけで評価できると思って時間を溶かす．そんなわけない．</description>
    </item>
    
    <item>
      <title>SRM659 Div1Easy ApplesAndOrangesEasy</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/26/</link>
      <pubDate>Mon, 26 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/26/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=13791&amp;amp;rd=16462
概略 果物（リンゴまたはオレンジ）を順に $N$ 個食べる．info[i]番目は必ずリンゴを食べる．直近 $K$ 個の内，リンゴは最大でも $\left\lfloor \dfrac{K}{2} \right\rfloor$ 個までしか食べてはいけないとき，全体で食べるリンゴの最大値を求める．
方針 左から見ていき，リンゴを食べられるならば必ず食べる貪欲をします．$i$ 番目にリンゴを食べるとその影響は $i + K - 1$ 番目まで及ぶため，後回しにして同じ個数を食べられる可能性はあっても，それより多く食べることはできません（？）．
あとは $i$ 番目でリンゴが食べられるかを判定できればよく，これは全ての $0 \leq d &amp;lt; K$ について $[i - d, i + (K - d))$ に含まれるリンゴが $\left\lfloor \dfrac{K}{2} \right\rfloor$ 個未満であることが条件です．
[展開する]   反省 貪欲の証明があっているのかわからない．脳死でセグ木を貼らない．</description>
    </item>
    
    <item>
      <title>SRM681 Div1Easy FleetFunding</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/21/</link>
      <pubDate>Wed, 21 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/21/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14104
概略 宇宙船1隻を作るには，$m$ 種類のパーツが1つずつ必要である．また，店が $n$ 個ある．店 $i$ は種類 $[a_i, b_i]$ のパーツを合計 $k_i$ 個まで売ってくれる．
宇宙船は最大何隻作れるか．
方針 $x$ 隻作れるかを二分探索します．判定にはパーツの種類を時間軸に持った，区間スケジューリング的な考え方を用います．パーツの種類を昇順に見ていき，現時点で購入可能な店について $b_i$（区間の上限）の昇順に合計 $x$ 個購入します．途中で購入可能な店が無くなった場合，失敗です．このような操作は優先度付きキューを2本持つことで簡単に実現できます．
パーツの総数は $\sum k \leq nk _ {\max}$ なので操作回数は大体 $m \log \dfrac{n}{m}k _ {\max}$ で，これはおよそ $10^6$ です．
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM671 Div1Easy BearCries</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/20/</link>
      <pubDate>Tue, 20 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/20/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14010
概略 泣き顔とは，2つのセミコロンでアンダースコア1つ以上を囲んだもののことを言う．正規表現では;_+;である．
与えられたmessageをいくつかの部分列に分ける分け方のうち，過不足なく泣き顔が作れる分け方は何通りあるか．
方針 dp[i][a][b] := iまで見て使っていない&amp;quot;;&amp;quot;がa個，&amp;quot;;_+&amp;quot;がb個とします．過不足なく使うことを考えると，解はdp[|message|][0][0]です．
kmjpさんのブログの言葉を借りて，;_+;は「閉じている」，;_*は「開いている」と表現すると次のような遷移が考えられます．
 セミコロンが来たとき  新たに開く dp[i][a][b] += dp[i - 1][a - 1][b] 1つ閉じる dp[i][a][b] += dp[i - 1][a][b + 1] * (b + 1)  アンダースコアが来たとき  開いている;のみの状態に追加する dp[i][a][b] += dp[i - 1][a + 1][b - 1] * (a + 1) 開いている;_+の状態に追加する dp[i][a][b] += dp[i - 1][a][b] * b   [展開する]   反省 最初，普通に数学をして壊滅した．DP解に目標を絞るも，dp[i][a][b] := iまで見て使っていない&#39;;&#39;がa個，&#39;_&#39;がb個からなかなか進まなかった．;，;_のような区別の仕方は典型なので，気づけなかったのは反省．
参考  ABC104D - We Love ABC  </description>
    </item>
    
    <item>
      <title>SRM757 Div1Easy CentipedeSocks</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/15/</link>
      <pubDate>Thu, 15 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/15/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=15445&amp;amp;rd=17496
概略 足が $F$ 本のムカデが $C$ 匹いる．それぞれのムカデはすべての足に同じ色の靴下を履かないと満足しない．靴下はビンに入っていて，各色の本数の内訳はvectorで示される．ビンからランダムに靴下を取り出していき，同色が $F$ 本揃った時点でムカデに履かせる．
すべてのムカデが満足するためにビンから取り出す靴下の本数の最大値を求める．
方針 最終的にできるだけ多くの靴下を無駄にしたいです．そこで次のような貪欲を考えます．
「残りの本数から $F$ 本取ったあとに追加で取れる本数の多い順に取る」 わかりづらいので実装したアルゴリズムを使って，適当な入力を処理します．あとは頑張ってください．
F = 5, s(sockCounts) = {1, 3, 6, 7, 10, 14}とします．
 Fに満たないものを全部取ります．  ans += 1 + 3 s = {6, 7, 10, 14}  sをソートして貪欲に取っていきます．ルールは「F本取ったあとに追加で取れる本数の多い順に取る」です．括弧内が指標です．F本取れる場合にはカウントCが減っていきます．今回はC = 5とします．  {14(4), 10(4), 7(2), 6(1)} {10(4), 9(4), 7(2), 6(1)}  C = 4 ans += 5  {9(4), 5(4), 7(2), 6(1)}  C = 3 ans += 5  {5(4), 4(4), 7(2), 6(1)}  C = 2 ans += 5</description>
    </item>
    
    <item>
      <title>SRM715 Div1Easy MaximumRange</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/08/14/</link>
      <pubDate>Wed, 14 Aug 2019 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/08/14/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=14613
概略 +，-からなる文字列がある．+はインクリメント，-はデクリメントに相当する．初期値を0として左から操作を行い，操作中の最大値と最小値の差がスコアになる．
与えられた文字列の部分列についても同様に操作が行えるとき，スコアの最大値はいくらであるか．
方針 +または-のみを取ることで簡単にスコアを最大化できます．最大値と最小値のペアを $(\max, \min)$ と表すことにします．+のみが $A$ 個ある操作列は $(A, 0)$ で，スコアは $A$ です．ここに-を $B$ 個加えてみましょう．スコアを上げるには最小値を小さくするしかなく，相殺する位置には置けません．
 先頭に加えたとき : $(\max(A - B, 0), -B)$  スコア : $\max(A, B)$  殿に加えたとき : $(A, \min(A - B, 0))$  スコア : $\max(A, B)$   が考えられますが，これは結局，+または-のみを取れば良いことを示しています．
[展開する]   </description>
    </item>
    
    <item>
      <title>ICPC 2019 Yokohama Regional Online First Round Contest</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/07/13/</link>
      <pubDate>Sat, 13 Jul 2019 11:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/07/13/</guid>
      <description>ABC3完で45位/学内2位，選抜順位だと32位でしょうか．よくわかっていません．とりあえずアジアには進めそうです．裏目標の「ホスト枠を自チームで潰さない」が達成できたので良かったです．
チーム 「chmod rw-rw&amp;mdash;x」は学科同期3人のチームでした．あえてIDで書きます．
 ChiyosBigDragon morio__ daruma3   構文解析と幾何だけは担当がありますが，それ以外は適当です．
作戦 練習会や模擬国内を経験して，本番は次のようなフローで臨みました．
 印刷タスク + A（考察実装：もりを） B と C の実装の軽いほう（考察実装：ぼく） (B or C) と D の実装の軽いほう（考察：だるまともりを，実装：もりを） …  Cまでは自明問（実装は知らない）が出ると仮定して，3完早解き(+1,2完)を狙っています．学内の状況を考えると4完で確定ラインなのですが，4完前提の立ち回りをして壊滅すると不味いので，3完まで確実に潰し累積ペナルティを減らしに行きます．学内上位ならば最悪†ホスト校†で拾ってくれるので，悪い作戦ではないように見えますが，これを考える人の性格は悪そうです．
本番 始まると同時にもりをが印刷タスクを投げます．学内の印刷機にはログインをしなければいけないのですが，ログインすると既にタスクが上がっていて流石でした．今年は印刷機が遠かったので歩きながら問題に目を通すと，Bの実装が無なことに気付きます．だるまにAの次がBであることを伝え，代わりにCをやってもらいます．FAのプロもりをにかかれば，Aは扇風機の前のガリガリ君レベルで溶けてしまうので，わずかな待機時間でできるだけ問題や入力を頭に叩き込みました．
Bは空文字以外ユニークが強すぎる．mapで文字ごとに座標を記録しておけば，各回の操作回数はマンハッタン距離 $+1$ です．ほとんどミスなしでしたがFAとはなりませんでした．高級寿司店で損をする人間なので妥当な結果です．2完．
Cの考察が不十分らしいので，問題概要を聞いて考察に参加します．$3^n$ で重さを列挙すること，必要な分銅をmapで持つことまで方針を固めたところで実装に移りました．割と非自明だったのでペアプロです．途中まで良かったのですが肝心の答えが合いません．やっぱり考察と実装は分けるべきですね．手動解とエラー出力を突き合わせながらデバッグをすると，手持ちの分銅でどうにかなる薬を除去していないことに気付きます．ここで解法が確信に変わったので後のデバッグはサンプルが合うようにエスパーで修正していきます．完成したところで本入力を食わせると中々に時間がかかっていてビビりますが，ICPCはこんなものという印象があるのでそのまま提出します．3完．
ここでいったん順位表を見ます．正直，Cに時間をかけすぎたと思っていたので，学内1位を確認したときにはかなり安心しました．他の問題に目を通すと，
 D : セグ木みたいな操作しそう E : $5! \times 8^5$ をやるだけ？実装が重すぎる F : 操作してできるグラフが $O(2^n)$ ないか？ G : $10^{18}$ の構文解析はもはやトラウマと言っても良い  という印象．Eはやるだけですが，順位表から嫌な雰囲気が出ていたのでDを解くことに．
この後，2時間ぐらい椅子を温めます．Dで区間DPを実装しますが合いません．考察が間違っています．ここでEに切り替えることができれば4完だったかもしれませんが，謎の自信でデバッグをしていきます．切り替えたいがEを実装する時間はないみたいな状況になって終了．だるまがEを詰めてくれていたのに申し訳ない気持ち．
おわり 最終盤で学内2位に落ちてからお祈りモードでした．終わってみると通常の選抜枠で抜けていますが，若干の不完全燃焼感があります．裏目標は上で述べたとおりですが，表目標は「ボーダーが発生しない完答数で通過」でした．今回だと4完以上です．アジア予選までは時間があるので精進を頑張ろうと思います．大学から支援が出るとか出ないとか（多分出ないけど）の話があるので国外も視野に入れています．ワクワクコンテストとか出てみたいですね．</description>
    </item>
    
    <item>
      <title>SRM759 Div1Easy EllysThreePrimes</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/05/30/</link>
      <pubDate>Thu, 30 May 2019 09:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/05/30/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=15436
概略 5桁の素数 $A, B, C$ がある．各桁の和が与えられるので，これを満たす $(A, B, C)$ の組を1つ求める．ただし $A, B, C$ は互いに異なる．
方針 $A, B$ を決め打つ全探索がしたくなる．5桁なので $O(n^2)$ は怪しいが，色々工夫すると通る．
主な枝刈りは以下の通り．手元で1s前後．
 エラトステネスの篩で $A, B$ の候補を絞る． $A &amp;lt; B$ とする． $C$ の1桁目は偶数でも $5$ でもないので，そこで探索を打ち切る． $C$ の最上位は $0$ ではないので，そこでも探索を打ち切る． $C$ の素数判定は篩の中を二分探索する．（これは怪しい）  [展開する]   反省 どう頑張っても1sかかるので，ジャッジを信じて投げたら通った．あとでシステスを通したら最大で400msだった．信仰心が足りない．</description>
    </item>
    
    <item>
      <title>Google Code Jam 2019 - Round 2</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/05/19/</link>
      <pubDate>Sun, 19 May 2019 06:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/05/19/</guid>
      <description>QualのWriteUp R1AのWriteUp R1BのWriteUp R1CのWriteUp R2のWriteUp  結果 0完をしてしまった．悲しいのであまり言及しません．また来年．
数学のみをしないで欲しい 読解  A: いきなり難しそうだけど… B: 全部に入れたら勝てないか C: 読めません． D: はい絶対難しい  重そうなセットに見えたのでABに絞る．
A: New Elements: Part 1 なにを勘違いしたのか，C or Jが無限に大きい場合のみを考えてしまった．なので答えが1か2になって当然WA．
B: Pottery Lottery  とりあえず全部に100を入れたらめちゃくちゃ負けた．最小が複数あると干渉してダメなことにここで気付く． 透視に1ターンはかかり過ぎな気がするので投票に専念する． いくつかの花瓶を投票で潰して残りに100を入れた．  3個残しが190/250くらい出て，いけそう缶． 残ってる花瓶同士で干渉している？  潰す花瓶が多いとあまり潰れないし，少ないと干渉するし難しい．  とりあえず全部に100を入れておけば，干渉のみに気を使えて良さそう．  残りに傾斜が付くように投票するもむしろ下がる． 透視して最小を確認しても下がる． 最大風速で210/250ぐらい出た．  順位表を見るとやっぱり重いので，ひたすらパラメータをいじる． 最後までこれ．   明日からもおブスファッション 正直最初に目を通した時点で無理だと感じた．解いたことのないタイプの問題しかない．これは本当にプログラミングコンテストですか．
とはいえ上位はちゃんと通しているので完全に精進不足．R1Cの験を担いで直前にゲームをしてはいけなかった．
 Humble Storeで無料配布中なのでぜひ．まだ途中．まあまあ面白いのだがメトロイドヴァニアの既プレイにOriとHollow Knightがあるので…</description>
    </item>
    
    <item>
      <title>Google Code Jam 2019 - Round 1C</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/05/05/</link>
      <pubDate>Sun, 05 May 2019 06:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/05/05/</guid>
      <description>QualのWriteUp R1AのWriteUp R1BのWriteUp R1CのWriteUp R2のWriteUp  結果 AB2完60pt．414th．なんかstraightforwardでした．ゲームを直前までしてたのがよかったのかも．
A: Robot Programming Strategy 概略 手順のわかっているジャンケンマンがたくさんいるので，全員にワンコインで勝てる「対ジャンケンマンロボ」を作ろう．
雑感 今残っているジャンケンマン全部に，勝ちまたはあいこが出せればいい．実装ゲー．
今気付いたけど googol って $10^{100}$ じゃん．血の気が引いた．翻訳に投げたのをそのまま読んで10100を書いている．実際には1手で1台倒すはずだからこんなにループはいらないし，むしろ $A$ が大きかったらTLEだった．昨日のAGCもそうだが，よく嘘をついてしまう．
[展開する]   B: Power Arrangers 概略 {A,B,C,D,E}の順列 $120$ セットが1列に並んでいる．はずだったが1セット抜けているらしい．何回かの質問でどのセットが抜けているかを特定しよう．
雑感 最初に各セットの先頭を質問すると候補が1/5に減って，残りの各セットの2番目を質問すると候補が1/4に減って…．これはAを解いてたら自然な流れだと思う．
そう思うからこそ，Largeの質問回数を計算してたまげる． $$ 150 \geq 148 = 119 + 23 + 5 + 1 = 119 + \left( \dfrac{120}{5} - 1 \right) + \left( \dfrac{24}{4} - 1 \right) + \left( \dfrac{6}{3} - 1 \right) $$</description>
    </item>
    
    <item>
      <title>Google Code Jam 2019 - Round 1B</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/04/29/</link>
      <pubDate>Mon, 29 Apr 2019 06:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/04/29/</guid>
      <description>QualのWriteUp R1AのWriteUp R1BのWriteUp R1CのWriteUp R2のWriteUp  結果 Ac2完41pt．1815th．1811st．やっぱりちょっと上がりますね．Round1Cに進出．
A: Manhattan Crepe Cart 概略 より多くの人が向かう交差点の場所を特定しよう．
雑感 $(x,y)$ にいる人が $+x$ 方向を向いているなら交差点の候補は $(x&amp;rsquo;,y&amp;rsquo;) (x+1 \leq x&amp;rsquo; \leq Q, 0 \leq y&amp;rsquo; \leq Q)$
点の候補が $x,y$ について独立なので別々に求めることが出来る．集計はimos法が楽か．何故か配列を4つ用意してさらに添字ミスで1WA．
[展開する]   B: Draupnir 概略 X-day ringはX日で倍に増える．$d$ 日目のリングの総数を質問できるので，0日目での各リングの数を求めよう．
雑感 $W = 2$ って何．Smallであれば連立1次方程式を解くだけでいいのでネットに実装を探しに行く．Python+ガウスの消去法が見つかったので慣れないながらもやる．手元では合ったのにWAした．辛い．
Editorialにあった実装．
[展開する]   C: Fair Fight 概略 $$ \left| \max _ {l \leq i \leq r} {c[i]} - \max _ {l \leq j \leq r} {d[j]} \right| \leq K $$</description>
    </item>
    
    <item>
      <title>Google Code Jam 2019 - Round 1A</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/04/13/</link>
      <pubDate>Sat, 13 Apr 2019 15:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/04/13/</guid>
      <description>  QualのWriteUp R1AのWriteUp R1BのWriteUp R1CのWriteUp R2のWriteUp  結果 aC2完45pt．1500人通過で1584th1567th(何故か上がった)でした．まさかペナ差で落ちるとは…
A: Pylons 概略 $R\times C$のグリッドを後述するルールで動く駒がある．重複することなく全てのマスを踏めるならば，その動き方を示せ．
ルール 移動前の座標を $(r,c)$ ，移動後の座標を $(r&amp;rsquo;,c&amp;rsquo;)$ とする．以下のいずれにも該当してはいけない．
 $r = r&amp;rsquo;$ $c = c&amp;rsquo;$ $r - c = r&amp;rsquo; - c&amp;rsquo;$ $r + c = r&amp;rsquo; + c&amp;rsquo;$  雑感 全探索しかわからない．最初はSmallすらも落ちたが，1解に到達した時点で強制終了させたらなんとか通った．Largeはまったくわからない．桃色大戦ぱいろんは昔やってましたね．
[展開する]   B: Golf Gophers 概略 風車の羽根の枚数を毎晩いじって，ゴルフ場に棲むGopherの数を推定しよう．
雑感 残り30分を切ったころに読み始めた．インタラクティブで絶望．この時点で2完なのでSmallだけでもとりたい気持ち．SmallはGopherの数が少ないので，雑でも行けると思って書き始めたがTLE．風車は回らず，Qualのツケが回ってきた．今考えれば中国剰余だなあという感じ．みんなのGOLFは4を昔やってましたね．
C: Alien Rhyme 概略 与えられた単語からrhymeできるもの同士をペアにしたとき，最大何組ペアが出来るか．ただし同じ位置でのrhymeはありえんライムなのでやってはいけません．
雑感 後ろから見て共通する部分で木を作った．これを「trie木」と言うらしい．深さが1進むと，その位置でrhymeするペアを1組作れるので，作れるペアの数を返り値で管理してDFSした．共通部分が長いとペアの数が単語数を超えるので，きちんとminを取らないといけない．substrしまくったので計算量が不安だったがなんとかLargeも通った．バイオ41は昔やってましたね．
[展開する]   感想 あとの2回で通る気がしません．繰り上げとか，なさらないんですか？
 バイオ4空耳 完全版 &amp;mdash; YouTube[return]   </description>
    </item>
    
    <item>
      <title>BeautifulSoup4で某番組HPをスクレイピング</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/04/08/</link>
      <pubDate>Mon, 08 Apr 2019 23:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/04/08/</guid>
      <description>今回はここのページをスクレイピングします．使途未定ですが，同一人物の写真が大量にあるので解析に使えるかもしれないし使えないかもしれない．
春の番組改編でリニューアルしてましたけど何にも変わってなかったですね．でもホームページだけは変わってるんですよ．古いページは任天堂1を除いて十中八九消される運命なので救出しなければなりません．すでにバナー消えてたし．
解析 http://www.ntv.co.jp/anothersky/fashion/index.html http://www.ntv.co.jp/anothersky/fashion/index_2.html http://www.ntv.co.jp/anothersky/fashion/index_3.html … http://www.ntv.co.jp/anothersky/fashion/index_25.html  &amp;lt;div class=&amp;quot;entryBox clearfix&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;img&amp;quot;&amp;gt; &amp;lt;img src=&amp;quot;画像1&amp;quot;&amp;gt; &amp;lt;img src=&amp;quot;画像2&amp;quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;entryBody&amp;quot;&amp;gt; &amp;lt;h3&amp;gt;日付&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;詳細&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  another skyの雰囲気良いですよね．シンプルで洗練された印象があります．一つ気に食わない点があって，ワイプが斜めなんですよ．そこだけ変に立体感があってゴチャっと見えるというか．惜しい．
スクレイピング def scrape(soup) : pages = soup.find_all(class_=&#39;entryBox clearfix&#39;) for page in pages : div = page.find(class_=&#39;entryBody&#39;) # 日付取得 date = &#39;&#39;.join(div.find(&#39;h3&#39;).text.split()) dir = &#39;./data/&#39; + date + &#39;/&#39; os.mkdir(dir) # 詳細取得 details = div.find(&#39;p&#39;).text with open(dir + str(&#39;details.txt&#39;), &#39;w&#39;, encoding=&#39;utf-8&#39;) as file : file.</description>
    </item>
    
    <item>
      <title>Google Code Jam 2019 - Qualification Round</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/04/07/</link>
      <pubDate>Sun, 07 Apr 2019 19:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/04/07/</guid>
      <description>QualのWriteUp R1AのWriteUp R1BのWriteUp R1CのWriteUp R2のWriteUp  結果 AB2完41ptで通過した．CDも解くつもりでいたが，Cで多倍長整数が必要なことに気付いてやる気を無くした．Round1以降に多倍長が出たらこの人はどうするつもりなのだろうか．
A: Foregone Solution 概略 正整数 $N$ が渡されるので $N=A+B$ となるように分割する．ただし $A,B$ は正整数で $4$ を含んではならない．
$N$ には1つ以上 $4$ が含まれる．
雑感 読みやすくて助かる．桁ごとに見て，$4$ を $2+2$ に分解すればよさそう．この出力形式誰が得するんだ．
[展開する]   B: You Can Go Your Own Way 概略 正方形のグリッドを左上から右下に動く人がいる．この人と経路を共有しないように左上から右下に向かうにはどう動けばいいか．
雑感 即座に反転が思いついたがなぜか解法から外してしまった．まったく意味がわからない．結局場合分けをして解いた．結構重くなってしまった．
 左上から出る向きと右下に入る向きが違うとき  図のように端を通る．
 左上から出る向きと右下に入る向きが同じとき  鳩の巣原理から，同一方向に2連続で動くことがあるので，そこを狙って1回だけ交わる．図だと赤点を狙い撃ちしている．
[展開する]   感想 通過するだけなら意外と簡単だった．「Google Code Jam 2019 - Qualification Round通過 」って字面だけ見たら激強に見えるな．Googleすごい．実際に強いと言えるのはTシャツを貰ってからだと思っているので，そこまでは頑張りたい．調べたら残りの参加者は27610人らしい．1000/27610…</description>
    </item>
    
    <item>
      <title>ブログ記事中のスニペットを外部参照する</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/03/27/</link>
      <pubDate>Wed, 27 Mar 2019 10:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/03/27/</guid>
      <description>[展開する]   上を表示するためのHTMLは次の通りです．
&amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;language-cpp&amp;quot; src=&amp;quot;./sample.cpp&amp;quot;&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;  端的には&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;にsrc属性を追加します．
動機 最近はもっぱらラップトップでブログを書くわけですが，画面が小さく1，エディタとプレビューでいっぱいいっぱいになってしまいます．こんな状態でスニペットを含むMarkdownを開いた光景は，JR武蔵小杉駅の南武線ホームを彷彿とさせます．
スニペットを省略できれば全体の見通しが良くなることはもちろん，メンテナンス性の向上(?)も期待されます．どっかの数学者も言ってましたね．「ソースコードは分割せよ」って．
流れ  jQueryを読み込む DOMの書き換え Markdown  jQueryを読み込む 今回はjQueryを使うことにします．&amp;lt;head&amp;gt;内で読み込み．
&amp;lt;head&amp;gt; &amp;lt;script src=&amp;quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;head&amp;gt;  DOMの書き換え [展開する]   メモ  indexと書いたが実際は何を指しているのか不明．なんだろう．  Markdown 今回の記事のソースコードはこんな感じ．
--- title: &amp;quot;ブログ記事中のスニペットを外部参照する&amp;quot; date: 2019-03-27T10:00:00+09:00 draft: false topics: [&amp;quot;Programming&amp;quot;] tags: [&amp;quot;jQuery&amp;quot;, &amp;quot;HTML&amp;quot;] --- &amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;language-cpp&amp;quot; src=&amp;quot;./sample.cpp&amp;quot;&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 上を表示するためのHTMLは次の通りです． ```html &amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;language-cpp&amp;quot; src=&amp;quot;./sample.cpp&amp;quot;&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; ``` 端的には`&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;`に`src`属性を追加します． ## 動機 最近はもっぱらラップトップでブログを書くわけですが，画面が小さく[^1]，エディタとプレビューでいっぱいいっぱいになってしまいます．こんな状態でスニペットを含むMarkdownを開いた光景は，JR武蔵小杉駅の南武線ホームを彷彿とさせます． スニペットを省略できれば全体の見通しが良くなることはもちろん，メンテナンス性の向上(?)も期待されます．どっかの数学者も言ってましたね．「ソースコードは分割せよ」って． ## 流れ - [jQueryを読み込む](#jQueryを読み込む) - [DOMの書き換え](#DOMの書き換え) - [Markdown](#Markdown) ## jQueryを読み込む 今回はjQueryを使うことにします．`&amp;lt;head&amp;gt;`内で読み込み． ```html &amp;lt;head&amp;gt; &amp;lt;script src=&amp;quot;https://ajax.</description>
    </item>
    
    <item>
      <title>SRM753 Div1Easy MaxCutFree</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/03/22/</link>
      <pubDate>Fri, 22 Mar 2019 14:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/03/22/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=15257
概略 単純無向グラフ $G$ が与えられる．$G$ の橋を含まないような誘導部分グラフのうち，頂点数が最大となるものを求める．
方針 要は，$G$ から橋だけを残したグラフについての最大独立集合問題である．このグラフは明らかに森であるから，木DPが使える．
参考  制約が甘いので橋の検出にはUnionFindを使う．各辺ごとにそれを除いたグラフを構築し，端点の連結性を判定する．
[展開する]   反省 本番では橋の検出までしかできなかった．最大独立集合問題であることにはなんとなく気付いていたが，名前だけが先走った．「NP困難じゃん…」
dp等の初期化も忘れずに．</description>
    </item>
    
    <item>
      <title>Node.jsで作る番組情報通知Bot</title>
      <link>https://chiyosbigdragon.github.io/blog/2019/03/13/</link>
      <pubDate>Wed, 13 Mar 2019 18:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2019/03/13/</guid>
      <description>  実行結果 小さいかもしれませんね．すみません．
先に この記事は下記事の内容をパクったと言っても過言ではありません．
 もはや写経ですが勉強記録用なので．
動機 時の流れか，我が家では4月から新聞の購読を停止することになりました．非常に残念であります．かくいう私も，新聞をまともに読んでいたのはGコードが消えるか否かのころまでだったと思います．今ではラテ欄とスポーツ欄に隔月で発生する大相撲ぐらいしか読んでいません．あと下世話な週刊誌の広告．
テレビっ子な私はラテ欄の代替を探さなければならないわけですが，Webの番組表の扱いにくさは厳しいものがあります．あの縦長どうにかなりませんか．あの中で見たい番組を探すのは至難の技でしょう．こんな状態なので最低限，自分が興味のある番組くらいは抑えておきたいわけです．スクレイピングはPythonでかじっているので苦労はしないと思うのですが．
流れ  手作業でのURL取得 スクレイピングと整形 Slackへの通知 実行  手作業でのURL取得 番組を探す &amp;mdash; Gガイド.テレビ王国で見たい番組のキーワードや芸能人の名前を入力しURLを生成します．ここ一番ダサいです．試しに地上波+金属バット1で検索します．
https://tv.so-net.ne.jp/schedulesBySearch.action?condition.genres[0].parentId=-1&amp;amp;condition.genres[0].childId=-1&amp;amp;stationPlatformId=1&amp;amp;condition.keyword=%E9%87%91%E5%B1%9E%E3%83%90%E3%83%83%E3%83%88&amp;amp;submit=%E6%A4%9C%E7%B4%A2&amp;amp;descriptive=true
このURLとページのソースを元にスクレイピングしていきます．url.jsonには後で使う情報を入れておきます．
url.json [展開する]   スクレイピングと整形 TV_scrape.js [展開する]   メモ  ライブラリはcheerio-httpcliを使う．requireはimportみたいなものだろうか． 関数名の前にasyncを置くと内部でawaitが使える．awaitは待機と例外処理を担う？ index側からfetchにURLを投げる． タグはそのまま，idは#，classは.を付けて表現する． module.exportsは外から呼んだときに使えるようにするもの？  Slackへの通知 slack.js [展開する]   メモ  一言一句違わず申し訳ない気持ちになる． やっていることは単純だが一から書くとなると…  index.js 通知といったら瓦版なのでチャンネル名は#瓦版です．fetchの前にawaitを入れないとエラーを吐くので気を付けます(1敗)．
[展開する]   実行 node index.js   角界のロボコップ
他にやりたいこと  AWSで定期的に実行． Slackのslash-commandを用いた検索条件の追加削除．  今回はここまで．

 金属バット (お笑いコンビ) &amp;mdash; Wikipedia[return]   </description>
    </item>
    
    <item>
      <title>SRM512 Div1Easy MysteriousRestaurant</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/09/11/</link>
      <pubDate>Tue, 11 Sep 2018 09:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/09/11/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11295
概略 $N$ 日間だけ開くレストランがある．メニューは $M$ 種類あり，その値段は日ごと，メニューごとに異なる．
また，注文するメニューは $7$ 日前と同じでなくてはならない．
1日1回注文をするとして，財布の限り粘るとすると何日間粘ることが出来るか．
方針 サンプル1を見ると，1日だけいる場合と8日いる場合とでは，取る料理の種類が異なることがわかる．なので日を進めるたび，曜日( $7n$ 日前)の料理をおさらいして最小コストを再計算してやるとよい．
7日目まではソートして一番左にくるやつを選ぶ．以降は曜日でかかったコストをいったんbudgetに戻してから再計算．この方法だと貪欲にやってる感が強いので見通しはいい．
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM511 Div1Easy Zoo</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/09/05/</link>
      <pubDate>Wed, 05 Sep 2018 09:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/09/05/</guid>
      <description> これ本家のカテゴリが Recursion なんですけど，どうなんですかね．
URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11485
概略 ウサギとネコが合わせて $N$ 匹いる．彼らの身長は互いに異なる．
1匹ずつに次の質問をする． 「あなたと同じ種類で，あなたよりも身長が高い動物は何匹いるか？」
彼らの回答が全て正しいものとするとき，それを構成するウサギまたはネコの割り当ては何通りあるか．
補足 {0,0,1,1,2}という回答が得られたとき，ウサギをR，ネコをCとすると，
 {R,C,R,C,R} {R,C,R,C,C} {R,C,C,R,R} {R,C,C,R,C} {C,R,R,C,R} {C,R,R,C,C} {C,R,C,R,R} {C,R,C,R,C}  の8通りが考えられます．
方針 $2^{40}$ をシミュレートすることはまず無理．
とりあえずanswersをソートしてみる．ウサちゃんもネコちゃんも同じ身長の同種はいないとのことなので，構築可能であるとき，
answers={0,0,1,1,2,2,…,n-1,n-1,n,n+1,n+2,…,m}
になる．逆にこうでないものは全て弾く必要があってこれが結構面倒．実装ではmapで数えてuniqueを取っている．
各数字へのウサギとネコの割り振り方は，
$$ 2(多いほうがウサギかネコの2通り) \times 2^{n} = 2^{n+1} $$
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM510 Div2Medium TheLuckyGameDivTwo</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/09/04/</link>
      <pubDate>Tue, 04 Sep 2018 19:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/09/04/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11464
概略 Lucky numberは $4,7$ のみを含む数字である．
JohnとBrusはゲームをする．先ずJohnが長さjLenの区間を選ぶ．そのあとBrusが長さbLenの区間を「Johnが選んだ区間」の中から選ぶ．Brusが選んだ区間に含まれるLucky numberの数がポイントになる．
Johnがスコアを最大化するように，Brusがスコアを最小化するように戦術をとるとき，最終的なスコアはいくらになるか．
方針 範囲が $[1,4747]$ と狭いので全探索できそう．
Johnはスコアが大きくなるように，Brusはスコアが小さくなるように，それぞれ区間をとるというのがわかりにくい．こういう戦略最適化問題の場合，おおむね先手はエスパーなので，まずBrusの行動から考える．
BrusはJohnの決めた区間のうち，スコアが小さくなるよう更に区間を定める．つまり，Johnの各選択に対してスコアは一意に確定することがわかる．こうなると後は単純で，Johnはこの内スコアが最も大きくなる選択をすればいい．数学でやる1文字固定に近い．
どうせラッキーナンバーは少ないので，2進数を列挙する感覚で全部書き出した．春に受講した，ひたすらカルノー図を書く授業を思い出してちょっと鬱になった．
Brusが全範囲の最小値を必死に探す中，Johnはそのうちの最大値を高みの見物で選ぶ．そんな主従関係が目に浮かぶと書きやすいですね．
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM508 Div1Easy DivideAndShift</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/22/</link>
      <pubDate>Wed, 22 Aug 2018 16:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/22/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11434
概略 $1 \sim N$ のスロットが1列に並んでいる．プレイヤーは常にスロット $1$ の中身しか取得することができない．ゲームの目的は，開始時にスロット $M$ にあった中身を取得することである．
スロットには2通りの操作を行うことが出来る．
 Divide  $N$ を割り切れる素数 $p$ を選びスロットを $[1,\frac{N}{p}],[\frac{N}{p}+1,\frac{2N}{p}],…$ に分割する．この内，目的のスロットを含む部分列のみを保持する．その後，$N←\frac{N}{p}$とし，スロットの番号を $1 \sim \frac{N}{p}$ に振り直す．  Shift  スロットを左/右にシフトする．シフトするとスロット番号が $-1/+1$ だけ変化する．スロット $0$ は $N$ に，$N+1$ は $1$ に別途移動する．   最低で何回操作をすれば目的を達成できるか．
方針 全然できなかった．調べたら「DivideとShiftの操作は可換」ということがわかって（証明は知らない）そこからはノーヒントで行けた．これで250ptなんだ…
Shiftは数えるだけなので先にDivideを行う．Divideのやり方は高々、2^(素因数の数)だから全列挙してやればいい．あとは各々についてShiftの回数を求める．
のんきに数えてたらTLEしたので，剰余で考える必要があるのだが，これが難しかった．右にShiftする場合の式がよくわからなくて，手元のサンプルと帳尻を合わせるように書いたら通った（最悪）
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM504.5 Div1Easy TheNumbersWithLuckyLastDigit</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/21/</link>
      <pubDate>Tue, 21 Aug 2018 20:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/21/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11096
概略 $n$ が与えられる．$n$ を下1桁が $4$ または $7$ である正の数の和として表すとき，必要な項数の最小はいくつであるか．構成不可能であれば -1 を返す．
方針 $4+10k,7+10k$ を使うことが出来るので，$n$ が項数 $x$ で構成可能であるとき，$n+10k$ も項数 $x$ で構成可能．したがって $n$ の下1桁に注目してやればいい．
例えば下1桁が $3$ になるような項数最小の構成法は $$ 23 = 4 \times 4 + 7 \times 1 $$ である．これを下1桁 $0 \sim 9$ についてやればよく，結果下図が完成した．
   4と7で表せる数の下一桁   最小値未満の数は表せない 
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM506 Div1Easy SlimeXSlimesCity</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/16/</link>
      <pubDate>Thu, 16 Aug 2018 03:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/16/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11154
概略 $N$ 個の街があり各々には名前がついている．2つの街の合併を繰り返し，最終的に1つにすることを考える．
合併前の街の人口を $i,j (i \leq j)$ とする．
 $i &amp;lt; j$ のとき  合併後の街の名前は $j$ を継承する．  $i = j$ のとき  合併後の街の名前は $i$ または $j$ を継承する．   最終的に街が1つになったとき，その名前として取り得るものは何通りか．
方針 B - Colorful Creatures &amp;mdash; AtCoder Grand Contest 011
サンプル5の解釈を説明する．
ソートして人口の昇順に並べても一般性は失われない．また赤は累積和である．
合併のルールから，自分より人口の少ない街は無条件に取り込めるので全て取り込むことにする．これで増えた人口でも1つ右の街が取り込めなければ，その街が生き残ることはない．最終目標は全ての街を合併することなので，右から赤と黒を判定をしていき，図の点線のように断層ができるまでの数が答え．
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM505 Div2Medium PerfectSequences</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/14/</link>
      <pubDate>Tue, 14 Aug 2018 14:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/14/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11397
概略 perfect sequence とは以下の条件をともに満たす数列である．
 全要素が非負整数 全要素の積と和が等しい  seq の要素をひとつだけ変更して perfect sequence が作れるかを判定する．
方針 $$ S_i = \frac {\sum_k{seq[k]}} {seq[i]} $$ $$ P_i = \frac {\prod_k{seq[k]}} {seq[i]} $$ とすれば，perfect sequenceが作れる時 $$ S_i + x = T_i \times x ⇔ S_i = (T_i - 1) \times x $$ をみたす $x$ が1つ以上の $i$ で存在する．
ただし以下の点に注意．
 変更しないのはダメ． seq のサイズが1なら必ず Yes $T_i - 1 = 0$ のとき0除算で危ない．この場合， $S_i = 0$ であればよい。  最悪のケースだと $T_i \approx 10 ^ {9 \times 50}$になってオーバーフローするからこのコードはダメなはず…だけど，普通に通る．</description>
    </item>
    
    <item>
      <title>SRM505 Div1Easy RectangleArea</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/10/</link>
      <pubDate>Fri, 10 Aug 2018 22:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/10/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11400
概略 小長方形を組み合わせた長方形の盤面が与えられる．小長方形の各々について，面積がわかっていればY，そうでなければNと表記される．質問をするたび，任意のNが1つYに変化する．最低で何回質問をすれば盤面全てをYに変えられるか．
方針 図の赤枠のように長方形をとる．このとき，頂点と接する4つの小長方形に着目する．
 図より，このうち3つの面積がわかっている(Y)ならば，残り1つの面積もわかる．このような作業を繰り返すといずれ盤面のYが増えなくなるため，小長方形の面積を質問する必要がある．
質問する小長方形はどれでもよさそうだが確証はない．
追記1: ケースが大きいとTLEするらしい．再帰部分が明らかに怪しいがいまいちわからない．改善中…
追記2: creepさんなどの記事を参考にして通しました．TLE解では再帰時に頂点を全探索していたので $O(W^2H^2)$ だったが，実際にはN→Yとしたところに関係する場所しか変わらないので，$O(WH)$ に減らせるはず．結果として全体では $O(W^3H^3)$ → $O(W^2H^2)$ に削減．
 改善後 [展開する]   改善前 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class RectangleArea { public: int h,w; int board[51][51]; int ret=-1; void greed(){ for(int y=0;y&amp;lt;h-1;y++){ for(int x=0;x&amp;lt;w-1;x++){ for(int dy=y;dy&amp;lt;h;dy++){ for(int dx=x;dx&amp;lt;w;dx++){ if(board[y][x]+board[y][dx]+board[dy][x]+board[dy][dx]==3){ board[y][x]=board[y][dx]=board[dy][x]=board[dy][dx]=1; greed(); } } } } } } int minimumQueries( vector &amp;lt;string&amp;gt; known ){ h=known.size(); w=known[0].size(); for(int y=0;y&amp;lt;h;y++){ for(int x=0;x&amp;lt;w;x++){ if(known[y][x]==&#39;Y&#39;) board[y][x]=1; else board[y][x]=0; } } while(1){ ret++; greed(); bool end=true; for(int y=0;y&amp;lt;h;y++){ for(int x=0;x&amp;lt;w;x++){ if(board[y][x]==0){ board[y][x]=1; end=false; break; } } if(!</description>
    </item>
    
    <item>
      <title>SRM504 Div1Easy MathContest</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/08/04/</link>
      <pubDate>Sat, 04 Aug 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/08/04/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11233
概略 ボールが1列に並んでおり，先頭から順に取り出す．取り出したボールの色によって，列に以下の操作がなされる．
 white  列を反転させる  black  色を反転させる   操作終了までに取り出したblackの数を求める．
方針 愚直に再現すればよさそう．でも色反転の操作がダルそうだったので，状態を別で保持しxorを使うことで省略．初めは以下のコードをsubmitしたが，システスでTLE．よく考えれば $O(N^2)$ なので当然．
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class MathContest { public: int countBlack( string ballSequence, int repetitions ) { int n=ballSequence.size(); vector&amp;lt;bool&amp;gt; balls; for(int i=0;i&amp;lt;repetitions;i++){ for(int j=0;j&amp;lt;n;j++){ if(ballSequence[j]==&#39;B&#39;) balls.push_back(1); else balls.push_back(0); } } int black=0; bool rev=1; while(balls.size()){ bool color=balls.front(); balls.erase(balls.begin()); if(color^rev){ reverse(balls.begin(),balls.end()); }else{ rev=!rev; black++; } } return black; } };   一番上を取り出すときのerase スタック反転時のreverse  この二つが $O(N)$ なので省略する必要があったが，ここで異常に悩む．eraseの代替をpop_backで考えていたため，reverseと両立できなかったのが原因．結局，reverseは色反転と同じようにフラグ管理で，eraseはindexを操作することで解決．</description>
    </item>
    
    <item>
      <title>SRM503 Div1Easy ToastXToast</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/07/31/</link>
      <pubDate>Tue, 31 Jul 2018 16:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/07/31/</guid>
      <description> URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11204
概略 $N$ 種のパンについての情報underとoverが与えられる．各種のパンには $X_i$ が定められており，これより小さいパンはunder，大きいパンはoverである．$\min N$ はいくらであるか．条件を満たすパンが存在しない場合-1を返す．
方針 最初サンプル3の意味がわからなくて焦った.
1列に並べた時に
 左端にover || 右端にunder  そんなパンはないので，-1  underとoverが完全に分かれている  Xがその間に置けて，1  その他  下図より，2（のはず）   [展開する]   </description>
    </item>
    
    <item>
      <title>SRM502 Div1Easy TheLotteryBothDivs</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/07/27/</link>
      <pubDate>Fri, 27 Jul 2018 21:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/07/27/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11359
概略 &amp;quot;000000000&amp;quot;～&amp;quot;999999999&amp;quot;のうち，goodSuffixesを含むものを当たりとするときの当選確率を求める．
方針 単純に数えると重複が生じることに気を付ける．集合を意識すると良い．
 goodSuffixes={&amp;quot;47&amp;quot;,&amp;quot;4747&amp;quot;}とすると，&amp;quot;4747&amp;quot;$\subset$&amp;quot;47&amp;quot;なので&amp;quot;4747&amp;quot;を数える必要はない．  そこでgoodSuffixesを桁数の小さい順に並べて，集合の大きい方のみを数えるようにする．
追記: 昔のコード酷すぎるな．whileのくだりはusedかなんかで管理したほうが絶対良い．
[展開する]   テストおわったのでしっかり精進します</description>
    </item>
    
    <item>
      <title>SRM501 Div1Easy FoxPlayingGame</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/07/26/</link>
      <pubDate>Thu, 26 Jul 2018 17:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/07/26/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11284
概略 初期スコアを0として2種類の行動を任意の順番で行う．
 A: scoreAを足す． B: scoreBを掛ける  Aを $nA$ 回，Bを $nB$ 回行うときのスコアの最大値を求める．
方針 1年生 (A First Grader) &amp;mdash; Aizu Online Judge を解いた経験からDP解を思いつくも，うまくいかない．しぶしぶ考察すると，「足してから掛けたい」「正負は融通が利くので絶対値を大きくしたい」など思いついたため，全部入れ込んだ．場合分けはコードを参照．
[展開する]   追記：他人の解法が鮮やかすぎて直視できない</description>
    </item>
    
    <item>
      <title>SRM500 Div1Easy MafiaGame</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/07/19/</link>
      <pubDate>Thu, 19 Jul 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/07/19/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11342
概略 このゲーム，言語化が難しい．
 $N$ 人には0-indexedで番号が振られている．またvulnerableには最初 $N$ 人全員がいる． 以下の手順でゲームは進行する．   vulnerable内で $N$ 票を振り分ける．  vulnerable&amp;amp;&amp;amp;decisionsの人はdecisionsで宣言された分だけ得票する．  vulnerable={0,1,3}，decisions={0,1,1,2}の場合，0は1票，1は2票を得る．2はvulnerableに含まれないので得票しない．  上で $k$ 票消費されたとする．余った $N-k$ 票は得票数の最小値が大きくなるよう，均等に振り分ける．  5人の得票数が{1,0,3,2,1}で残り5票ある場合，以下のように分ける． {1,0,3,2,1}→{1,1,3,2,1}(1票消費)→{2,2,3,2,2}(4票消費)→{3,2,3,2,2}(5票消費) ただし5票目に選ばれる人物は2票得ている者の中からランダム   票数の最も大きい者のみがvulnerableに残る． vulnerableが1人になるまで投票を繰り返す．最後に残った1人が敗者となる．  各人が敗者となる確率を $p[i]$ としたときの $\max p$を計算する．なお，ゲームが終わらない場合には0を返す．
方針 「ゲームが終わらない」というのは，ゲーム中のある時点でvulnerableのサイズが不変，つまりvulnerable内の得票数が全て等しくなるということである．この判定法は投票の回数で異なる．
 投票1回目  vulnerableには $N$ 人全員がいるので，decisionsに複数現れる人物がいない場合，全員の得票数は1となってループ.  投票2回目以降  decisionsに係る投票を終えた時点で，vulnerable内の得票数は等しい（そういう風に投票1回目で分けます）．残りの票を振り分けたときに同票であるとループする．vulnerableのサイズを $i$ とするとループの条件は、$N\equiv 0\pmod i$   ループの条件がわかったのでシミュレーションができる．敗者は1回目の投票後にvulnerableにいる人のいずれかであり，彼らに区別はない．よって確率は、$1/i$
[展開する]   </description>
    </item>
    
    <item>
      <title>SRM500 Div2Easy SRMCards</title>
      <link>https://chiyosbigdragon.github.io/blog/2018/07/18/</link>
      <pubDate>Wed, 18 Jul 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/blog/2018/07/18/</guid>
      <description> URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11341
概略 数列が空になるまで以下の操作を繰り返す．
 数列から1つ数字を選びこれを消す． 上で選んだ数字を $n$とするとき，数列に $n\pm 1$ が存在すればこれ(ら)も同時に消す．  取り得る操作回数のうち最大を求める．
方針 ソートして小さい順に選択すると最大．証明は苦しいが，3個同時に消せる場面では必ず2-1と2回に分けて消せることに注意する．
[展開する]   </description>
    </item>
    
  </channel>
</rss>