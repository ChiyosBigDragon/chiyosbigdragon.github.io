<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spielsand</title>
    <link>https://chiyosbigdragon.github.io/</link>
    <description>Recent content on Spielsand</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Wed, 27 Mar 2019 10:00:00 +0900</lastBuildDate>
    
	<atom:link href="https://chiyosbigdragon.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ブログ記事中のスニペットを外部参照する</title>
      <link>https://chiyosbigdragon.github.io/post/2019/03/27/20190327/</link>
      <pubDate>Wed, 27 Mar 2019 10:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2019/03/27/20190327/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34; src=&#34;https://chiyosbigdragon.github.io/post/2019/03/27/sample.cpp&#34;&gt;&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;上を表示するためのHTMLは次の通りです．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;language-cpp&amp;quot; src=&amp;quot;https://chiyosbigdragon.github.io/post/2019/03/27/sample.cpp&amp;quot;&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;端的には&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;に&lt;code&gt;src&lt;/code&gt;属性を追加します．&lt;/p&gt;

&lt;h2 id=&#34;動機&#34;&gt;動機&lt;/h2&gt;

&lt;p&gt;最近はもっぱらラップトップでブログを書くわけですが，画面が小さく&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，エディタとプレビューでいっぱいいっぱいになってしまいます．こんな状態でスニペットを含むMarkdownを開いた光景は，JR武蔵小杉駅の南武線ホームを彷彿とさせます．&lt;/p&gt;

&lt;p&gt;スニペットを省略できれば全体の見通しが良くなることはもちろん，メンテナンス性の向上(?)も期待されます．どっかの数学者も言ってましたね．「ソースコードは分割せよ」って．&lt;/p&gt;

&lt;h2 id=&#34;流れ&#34;&gt;流れ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#jQueryを読み込む&#34;&gt;jQueryを読み込む&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#DOMの書き換え&#34;&gt;DOMの書き換え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Markdown&#34;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jqueryを読み込む&#34;&gt;jQueryを読み込む&lt;/h2&gt;

&lt;p&gt;今回はjQueryを使うことにします．&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;内で読み込み．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;domの書き換え&#34;&gt;DOMの書き換え&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34; src=&#34;https://raw.githubusercontent.com/ChiyosBigDragon/chiyosbigdragon.github.io/master/js/srcReader.js&#34;&gt;&lt;/code&gt;&lt;/pre&gt;


&lt;h3 id=&#34;メモ&#34;&gt;メモ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;と書いたが実際は何を指しているのか不明．なんだろう．&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;markdown&#34;&gt;Markdown&lt;/h2&gt;

&lt;p&gt;今回の記事のソースコードはこんな感じ．&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SRM753 Div1Easy MaxCutFree</title>
      <link>https://chiyosbigdragon.github.io/post/2019/03/22/20190322/</link>
      <pubDate>Fri, 22 Mar 2019 14:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2019/03/22/20190322/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=15257
概略 単純無向グラフ $G$ が与えられる．$G$ の橋を含まないような誘導部分グラフのうち，頂点数が最大となるものを求める．
方針 要は，$G$ から橋だけを残したグラフについての最大独立集合問題である．このグラフは明らかに森であるから，木DPが使える．
参考  制約が甘いので橋の検出にはUnionFindを使う．各辺ごとにそれを除いたグラフを構築し，端点の連結性を判定する．
 反省 本番では橋の検出までしかできなかった．最大独立集合問題であることにはなんとなく気付いていたが，名前だけが先走った．「NP困難じゃん…」
dp等の初期化も忘れずに．</description>
    </item>
    
    <item>
      <title>Node.jsで作る番組情報通知Bot</title>
      <link>https://chiyosbigdragon.github.io/post/2019/03/13/20190313/</link>
      <pubDate>Wed, 13 Mar 2019 18:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2019/03/13/20190313/</guid>
      <description> 実行結果 小さいかもしれませんね．すみません．
先に この記事は下記事の内容をパクったと言っても過言ではありません．
 もはや写経ですが勉強記録用なので．
動機 時の流れか，我が家では4月から新聞の購読を停止することになりました．非常に残念であります．かくいう私も，新聞をまともに読んでいたのはGコードが消えるか否かのころまでだったと思います．今ではラテ欄とスポーツ欄に隔月で発生する大相撲ぐらいしか読んでいません．あと下世話な週刊誌の広告．
テレビっ子な私はラテ欄の代替を探さなければならないわけですが，Webの番組表の扱いにくさは厳しいものがあります．あの縦長どうにかなりませんか．あの中で見たい番組を探すのは至難の技でしょう．こんな状態なので最低限，自分が興味のある番組くらいは抑えておきたいわけです．スクレイピングはPythonでかじっているので苦労はしないと思うのですが．
流れ  手作業でのURL取得 スクレイピングと整形 Slackへの通知 実行  手作業でのURL取得 番組を探す &amp;mdash; Gガイド.テレビ王国で見たい番組のキーワードや芸能人の名前を入力しURLを生成します．ここ一番ダサいです．試しに地上波+金属バット1で検索します．
https://tv.so-net.ne.jp/schedulesBySearch.action?condition.genres[0].parentId=-1&amp;amp;condition.genres[0].childId=-1&amp;amp;stationPlatformId=1&amp;amp;condition.keyword=%E9%87%91%E5%B1%9E%E3%83%90%E3%83%83%E3%83%88&amp;amp;submit=%E6%A4%9C%E7%B4%A2&amp;amp;descriptive=true
このURLとページのソースを元にスクレイピングしていきます．url.jsonには後で使う情報を入れておきます．
url.json  スクレイピングと整形 TV_scrape.js  メモ  ライブラリはcheerio-httpcliを使う．requireはimportみたいなものだろうか． 関数名の前にasyncを置くと内部でawaitが使える．awaitは待機と例外処理を担う？ index側からfetchにURLを投げる． タグはそのまま，idは#，classは.を付けて表現する． module.exportsは外から呼んだときに使えるようにするもの？  Slackへの通知 slack.js  メモ  一言一句違わず申し訳ない気持ちになる． やっていることは単純だが一から書くとなると…  index.js 通知といったら瓦版なのでチャンネル名は#瓦版です．fetchの前にawaitを入れないとエラーを吐くので気を付けます(1敗)．
 実行 node index.js  角界のロボコップ
他にやりたいこと  AWSで定期的に実行． Slackのslash-commandを用いた検索条件の追加削除．  今回はここまで．

 金属バット (お笑いコンビ) &amp;mdash; Wikipedia[return]   </description>
    </item>
    
    <item>
      <title>SRM504.5 Div1Easy TheNumbersWithLuckyLastDigit</title>
      <link>https://chiyosbigdragon.github.io/post/2018/08/21/20180821/</link>
      <pubDate>Tue, 21 Aug 2018 20:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/08/21/20180821/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11096
概略 $n$ が与えられる．$n$ を下1桁が $4$ または $7$ である正の数の和として表すとき，必要な項数の最小はいくつであるか．構成不可能であれば -1 を返す．
方針 $4+10k,7+10k$ を使うことが出来るので，$n$ が項数 $x$ で構成可能であるとき，$n+10k$ も項数 $x$ で構成可能．したがって $n$ の下1桁に注目してやればいい．
例えば下1桁が $3$ になるような項数最小の構成法は $$ 23 = 4 \times 4 + 7 \times 1 $$ である．これを下1桁 $0 \sim 9$ についてやればよく，結果下図が完成した．
   4と7で表せる数の下一桁   最小値未満の数は表せない 
 </description>
    </item>
    
    <item>
      <title>SRM506 Div1Easy SlimeXSlimesCity</title>
      <link>https://chiyosbigdragon.github.io/post/2018/08/16/20180816/</link>
      <pubDate>Thu, 16 Aug 2018 03:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/08/16/20180816/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11154
概略 $N$ 個の街があり各々には名前がついている．2つの街の合併を繰り返し，最終的に1つにすることを考える．
合併前の街の人口を $i,j (i \leq j)$ とする．
 $i &amp;lt; j$ のとき  合併後の街の名前は $j$ を継承する．  $i = j$ のとき  合併後の街の名前は $i$ または $j$ を継承する．   最終的に街が1つになったとき，その名前として取り得るものは何通りか．
方針 B - Colorful Creatures &amp;mdash; AtCoder Grand Contest 011
サンプル5の解釈を説明する．
ソートして人口の昇順に並べても一般性は失われない．また赤は累積和である．
合併のルールから，自分より人口の少ない街は無条件に取り込めるので全て取り込むことにする．これで増えた人口でも1つ右の街が取り込めなければ，その街が生き残ることはない．最終目標は全ての街を合併することなので，右から赤と黒を判定をしていき，図の点線のように断層ができるまでの数が答え．
 </description>
    </item>
    
    <item>
      <title>SRM505 Div2Medium PerfectSequences</title>
      <link>https://chiyosbigdragon.github.io/post/2018/08/14/20180814/</link>
      <pubDate>Tue, 14 Aug 2018 14:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/08/14/20180814/</guid>
      <description>URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11397
概略 perfect sequence とは以下の条件をともに満たす数列である．
 全要素が非負整数 全要素の積と和が等しい  seq の要素をひとつだけ変更して perfect sequence が作れるかを判定する．
方針 $$ S_i = \frac {\sum_k{seq[k]}} {seq[i]} $$ $$ P_i = \frac {\prod_k{seq[k]}} {seq[i]} $$ とすれば，perfect sequenceが作れる時 $$ S_i + x = T_i \times x ⇔ S_i = (T_i - 1) \times x $$ をみたす $x$ が1つ以上の $i$ で存在する．
ただし以下の点に注意．
 変更しないのはダメ． seq のサイズが1なら必ず Yes $T_i - 1 = 0$ のとき0除算で危ない．この場合， $S_i = 0$ であればよい。  最悪のケースだと $T_i \approx 10 ^ {9 \times 50}$になってオーバーフローするからこのコードはダメなはず…だけど，普通に通る．</description>
    </item>
    
    <item>
      <title>SRM504 Div1Easy MathContest</title>
      <link>https://chiyosbigdragon.github.io/post/2018/08/04/20180804/</link>
      <pubDate>Sat, 04 Aug 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/08/04/20180804/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11233
概略 ボールが1列に並んでおり，先頭から順に取り出す．取り出したボールの色によって，列に以下の操作がなされる．
 white  列を反転させる  black  色を反転させる   操作終了までに取り出したblackの数を求める．
方針 愚直に再現すればよさそう．でも色反転の操作がダルそうだったので，状態を別で保持しxorを使うことで省略．初めは以下のコードをsubmitしたが，システスでTLE．よく考えれば $O(N^2)$ なので当然．
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class MathContest { public: int countBlack( string ballSequence, int repetitions ) { int n=ballSequence.size(); vector&amp;lt;bool&amp;gt; balls; for(int i=0;i&amp;lt;repetitions;i++){ for(int j=0;j&amp;lt;n;j++){ if(ballSequence[j]==&#39;B&#39;) balls.push_back(1); else balls.push_back(0); } } int black=0; bool rev=1; while(balls.size()){ bool color=balls.front(); balls.erase(balls.begin()); if(color^rev){ reverse(balls.begin(),balls.end()); }else{ rev=!rev; black++; } } return black; } };   一番上を取り出すときのerase スタック反転時のreverse  この二つが $O(N)$ なので省略する必要があったが，ここで異常に悩む．eraseの代替をpop_backで考えていたため，reverseと両立できなかったのが原因．結局，reverseは色反転と同じようにフラグ管理で，eraseはindexを操作することで解決．</description>
    </item>
    
    <item>
      <title>SRM503 Div1Easy ToastXToast</title>
      <link>https://chiyosbigdragon.github.io/post/2018/07/31/20180731/</link>
      <pubDate>Tue, 31 Jul 2018 16:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/07/31/20180731/</guid>
      <description> URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11204
概略 $N$ 種のパンについての情報underとoverが与えられる．各種のパンには $X_i$ が定められており，これより小さいパンはunder，大きいパンはoverである．$\min N$ はいくらであるか．条件を満たすパンが存在しない場合-1を返す．
方針 最初サンプル3の意味がわからなくて焦った.
1列に並べた時に
 左端にover || 右端にunder  そんなパンはないので，-1  underとoverが完全に分かれている  Xがその間に置けて，1  その他  下図より，2（のはず）    </description>
    </item>
    
    <item>
      <title>SRM502 Div1Easy TheLotteryBothDivs</title>
      <link>https://chiyosbigdragon.github.io/post/2018/07/27/20180727/</link>
      <pubDate>Fri, 27 Jul 2018 21:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/07/27/20180727/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11359
概略 &amp;quot;000000000&amp;quot;～&amp;quot;999999999&amp;quot;のうち，goodSuffixesを含むものを当たりとするときの当選確率を求める．
方針 単純に数えると重複が生じることに気を付ける．集合を意識すると良い．
 goodSuffixes={&amp;quot;47&amp;quot;,&amp;quot;4747&amp;quot;}とすると，&amp;quot;4747&amp;quot;$\subset$&amp;quot;47&amp;quot;なので&amp;quot;4747&amp;quot;を数える必要はない．  そこでgoodSuffixesを桁数の小さい順に並べて，集合の大きい方のみを数えるようにする．
追記: 昔のコード酷すぎるな．whileのくだりはusedかなんかで管理したほうが絶対良い．
 テストおわったのでしっかり精進します</description>
    </item>
    
    <item>
      <title>SRM501 Div1Easy FoxPlayingGame</title>
      <link>https://chiyosbigdragon.github.io/post/2018/07/26/20180726/</link>
      <pubDate>Thu, 26 Jul 2018 17:30:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/07/26/20180726/</guid>
      <description>URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11284
概略 初期スコアを0として2種類の行動を任意の順番で行う．
 A: scoreAを足す． B: scoreBを掛ける  Aを $nA$ 回，Bを $nB$ 回行うときのスコアの最大値を求める．
方針 1年生 (A First Grader) &amp;mdash; Aizu Online Judge を解いた経験からDP解を思いつくも，うまくいかない．しぶしぶ考察すると，「足してから掛けたい」「正負は融通が利くので絶対値を大きくしたい」など思いついたため，全部入れ込んだ．場合分けはコードを参照．
 追記：他人の解法が鮮やかすぎて直視できない</description>
    </item>
    
    <item>
      <title>SRM500 Div1Easy MafiaGame</title>
      <link>https://chiyosbigdragon.github.io/post/2018/07/18/20180718-2/</link>
      <pubDate>Wed, 18 Jul 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/07/18/20180718-2/</guid>
      <description> URL https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11342
概略 このゲーム，言語化が難しい．
 $N$ 人には0-indexedで番号が振られている．またvulnerableには最初 $N$ 人全員がいる． 以下の手順でゲームは進行する．   vulnerable内で $N$ 票を振り分ける．  vulnerable&amp;amp;&amp;amp;decisionsの人はdecisionsで宣言された分だけ得票する．  vulnerable={0,1,3}，decisions={0,1,1,2}の場合，0は1票，1は2票を得る．2はvulnerableに含まれないので得票しない．  上で $k$ 票消費されたとする．余った $N-k$ 票は得票数の最小値が大きくなるよう，均等に振り分ける．  5人の得票数が{1,0,3,2,1}で残り5票ある場合，以下のように分ける． {1,0,3,2,1}→{1,1,3,2,1}(1票消費)→{2,2,3,2,2}(4票消費)→{3,2,3,2,2}(5票消費) ただし5票目に選ばれる人物は2票得ている者の中からランダム   票数の最も大きい者のみがvulnerableに残る． vulnerableが1人になるまで投票を繰り返す．最後に残った1人が敗者となる．  各人が敗者となる確率を $p[i]$ としたときの $\max p$を計算する．なお，ゲームが終わらない場合には0を返す．
方針 「ゲームが終わらない」というのは，ゲーム中のある時点でvulnerableのサイズが不変，つまりvulnerable内の得票数が全て等しくなるということである．この判定法は投票の回数で異なる．
 投票1回目  vulnerableには $N$ 人全員がいるので，decisionsに複数現れる人物がいない場合，全員の得票数は1となってループ.  投票2回目以降  decisionsに係る投票を終えた時点で，vulnerable内の得票数は等しい（そういう風に投票1回目で分けます）．残りの票を振り分けたときに同票であるとループする．vulnerableのサイズを $i$ とするとループの条件は、$N\equiv 0\pmod i$   ループの条件がわかったのでシミュレーションができる．敗者は1回目の投票後にvulnerableにいる人のいずれかであり，彼らに区別はない．よって確率は、$1/i$
 </description>
    </item>
    
    <item>
      <title>SRM500 Div2Easy SRMCards</title>
      <link>https://chiyosbigdragon.github.io/post/2018/07/18/20180718-1/</link>
      <pubDate>Wed, 18 Jul 2018 12:00:00 +0900</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/post/2018/07/18/20180718-1/</guid>
      <description> URL http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=11341
概略 数列が空になるまで以下の操作を繰り返す．
 数列から1つ数字を選びこれを消す． 上で選んだ数字を $n$とするとき，数列に $n\pm 1$ が存在すればこれ(ら)も同時に消す．  取り得る操作回数のうち最大を求める．
方針 ソートして小さい順に選択すると最大．証明は苦しいが，3個同時に消せる場面では必ず2-1と2回に分けて消せることに注意する．
 </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://chiyosbigdragon.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chiyosbigdragon.github.io/about/</guid>
      <description>前ブログ(https://chiyosbigdragon.hatenablog.jp/) より移転中です．
今のところ不備しかありません．ごめんなさい．
ブログ以外の用途も模索中です．</description>
    </item>
    
  </channel>
</rss>